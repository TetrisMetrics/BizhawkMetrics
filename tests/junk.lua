
--
---- Memory domains on NES:
---- WRAM, CHR, CIRAM (nametables), PRG ROM, PALRAM, OAM, System Bus, RAM
--
--local spriteHeight = 8
--
--local function setDomain( newDomain )
--  local previousDomain = memory.getcurrentmemorydomain()
--  memory.usememorydomain( newDomain )
--  return previousDomain
--end
--
--local function visualizeSprite( index )
--  local y    = memory.read_u8( 4 * index + 0 )
--  local tile = memory.read_u8( 4 * index + 1 )
--  local attr = memory.read_u8( 4 * index + 2 )
--  local x    = memory.read_u8( 4 * index + 3 )
--
--  -- \note QuickNes and NesHawk cores differ in the origin of
--  -- gui.drawRectangle (bug?)
--  -- local topScanline = nes.gettopscanline() -- QuickNES
--  local topScanline = 0 -- NesHawk
--
--  local kSpriteWidth  = 8
--
--  gui.drawRectangle(
--    x, y + 1 - topScanline,
--    kSpriteWidth - 1, spriteHeight - 1,
--    0xB0FF00FF -- ARGB
--  )
--end
--
--local function visualizeSprites()
--  local previousDomain = setDomain( "OAM" )
--
--  for i = 0, 63 do
--    visualizeSprite( i )
--  end
--
--  memory.usememorydomain( previousDomain )
--end
--
--local guid2000 = event.onmemorywrite ( function()
--  local previousDomain = setDomain( "System Bus" )
--
--  -- Rely on read-only PPU registers returning the previous value written
--  -- to any PPU register. There doesn't seem to be any other way to
--  -- get the written value in BizHawk.
--  -- http://forums.nesdev.com/viewtopic.php?p=153077#p153077
--  local reg2000 = memory.read_u8( 0x2000 )
--
--  spriteHeight = bit.check( reg2000, 5 ) and 16 or 8
--
--  memory.usememorydomain( previousDomain )
--end, 0x2000 )
--
---- QuickNES core doesn't support onmemorywrite(), returns zero GUID
--assert( guid2000 ~= "00000000-0000-0000-0000-000000000000",
--"couldn't set memory write hook (use NesHawk core)" )
--
--print( "hardware-sprite-visualizer loaded" )


--boardGlobal = nil
--readBoard()
--
--function setUpBoardCallbacks()
--  print("setting up callbacks")
--  for r=0,19 do
--    for c=0,9 do
--      event.onmemorywrite(function()
--        if game ~= nil then
--          local addr = Addresses["Playfield"] + (10*r) + c
--          print(addr, memory.readbyte(addr))
--        end
--      end, addr)
--    end
--  end
--end
--
--setUpBoardCallbacks()
--
--event.onmemorywrite ( function()
--  print(memory.readbyte(0x0059))
--  memory.writebyte(0x0059, 3)
--  if(memory.readbyte(0x8614) == 0xA5) then
--    --print("hi", memory.readbyte(0x8614))
--    memory.writebyte(0x8614, 0xA9)
--  end
--end, 0x0059)
--
--
--linesCleared = 0
--memory.registerwrite(0x0056, 1, function ()
--  local newVal = memory.readbyte(0x0056)
--  if newVal ~= linesCleared then
--    print(newVal)
--    linesCleared = newVal
--  end
--end)





--function clear_controller()
--  is        = {}
--  is.start  = false
--  is.select = false
--  is.A      = false
--  is.B      = false
--  is.up     = false
--  is.down   = false
--  is.left   = false
--  is.right  = false
--  joypad.write(1, is)
--end

--local tetriminos = { 0, 0 }
--local playfield = createEmptyPlayfield()
--local ai = newAI(2)
--local movesIndex = 1
--local moves = { }
--local tetriminoType = 0
--
--buildOrientationTable()


--if (isPlaying(gameState)) then
--
--  calculateFitness(game, board)
--
--
--  if movesIndex <= #moves then
--    makeMove(tetriminoType, moves[movesIndex], movesIndex == #moves)
--    movesIndex = movesIndex + 1
--  else
--    unregisterYUpdatedListeners()
--    if spawned() then
--      tetriminoType = readTetrimino()
--      moves = search(tetriminos, playfield, ai)
--      movesIndex = 1
--      registerYUpdatedListeners()
--    end
--  end
--end



--local f = myAi.computeFitness()
--print("fitness is: ", f)
--
--
--local playfield = createEmptyPlayfield()
--readPlayfield(playfield)
--
--local playfieldUtil = newPlayfieldUtil()
--local e = newPlayfieldEvaluation()
--playfieldUtil.evaluatePlayfield(playfield, e)
--
--
--local WEIGHTS = {
--  1.0,
--  12.885008263218383,
--  15.842707182438396,
--  26.89449650779595,
--  27.616914062397015,
--  30.18511071927904,
--}
--
--local f2 = WEIGHTS[3] * e.wells
--         + WEIGHTS[4] * e.holes
--         + WEIGHTS[5] * e.columnTransitions
--         + WEIGHTS[6] * e.rowTransitions
--print("fitness2 is: ", f2)

--return f